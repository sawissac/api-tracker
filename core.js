import chalk from "chalk";
import fs from "node:fs";
import path from "node:path";

/* `let __dirname = import.meta.dirname;` is setting the variable `__dirname` to the directory name of
the current module using the `import.meta` object. */
let __dirname = import.meta.dirname;
let { log } = console;


/**
 * The function `keyDeff` compares two objects and returns the keys that are new or missing between
 * them.
 * @param obj1 - It seems like you were about to provide the first object for the `keyDeff` function.
 * Please go ahead and provide the object so that I can assist you further.
 * @param obj2 - It seems like you were about to provide the second object for the `keyDeff` function.
 * Please go ahead and provide the second object so we can compare it with the first object and
 * determine the differences in their keys.
 * @returns The `keyDeff` function returns an object with two properties: `new` and `missing`. The
 * `new` property contains an array of keys that are present in `obj2` but not in `obj1`. The `missing`
 * property contains an array of keys that are present in `obj1` but not in `obj2`.
 */
function keyDeff(obj1, obj2) {
  let keys1 = Object.keys(obj1).sort((a, b) => a - b);
  let keys2 = Object.keys(obj2).sort((a, b) => a - b);
  let deff = {
    new: [],
    missing: keys1,
  };

  keys2.forEach((ls) => {
    if (!keys1.includes(ls)) {
      deff.new.push(ls);
    } else {
      let idxOfKey1 = keys1.indexOf(ls);
      deff.missing[idxOfKey1] = null;
    }
  });

  deff.missing = deff.missing.filter((ls) => ls !== null);

  return deff;
}

/**
 * The function `keyDeffPrettifier` logs the keys that are new and missing in a given object difference
 * result in a visually appealing format.
 * @param deffResult - It looks like the `keyDeffPrettifier` function is designed to prettify and log
 * the differences in keys between two sets of keys provided in the `deffResult` object. The
 * `deffResult` object should have a `new` property containing an array of new keys
 */
function keyDeffPrettifier(deffResult) {
  log(chalk.bgGreen(chalk.bold("**Checking keys differences**")));
  let newKeys = deffResult.new.length
    ? deffResult.new.join(" , ")
    : "No Changes!";
  let missingKeys = deffResult.missing.length
    ? deffResult.missing.join(" , ")
    : "No Changes!";
  log(chalk.green(chalk.bold("+ " + newKeys)));
  log(chalk.red(chalk.bold("- " + missingKeys)));
}

/**
 * The function `autoGenerated` generates a unique identifier by combining a given size parameter with
 * the current date in a specific format.
 * @param size - Size refers to the parameter that is passed into the `autoGenerated` function. It is a
 * value that determines the size of something, which is then used in the function to generate a unique
 * identifier along with the current date.
 * @returns The function `autoGenerated` is returning a string that concatenates the `size` parameter
 * with a period (".") and the current date in the format "MMDDYYYY".
 */
function autoGenerated(size) {
  let date = new Date().toLocaleDateString().split("/").join("");
  return size + "." + date;
}



/**
 * The `save` function in JavaScript saves a JSON object to a specified directory with optional custom
 * file naming and indentation.
 * @param deepKeyResult - The `deepKeyResult` parameter in the `save` function is the data that you
 * want to save to a JSON file. It should be an object that you want to write to the file.
 * @param dir - The `dir` parameter in the `save` function represents the directory path where the JSON
 * file will be saved. It should be a string indicating the directory path relative to the current
 * file.
 * @param [indexing=2] - The `indexing` parameter in the `save` function is used to specify the spacing
 * in the JSON output file. It determines the number of spaces to use for each level of indentation in
 * the JSON string. This parameter helps in formatting the JSON output for better readability.
 * @param [fileName] - The `fileName` parameter in the `save` function is used to specify the name of
 * the file where the `deepKeyResult` will be saved. If a specific file name is not provided, the
 * function will generate a file name automatically based on the existing files in the specified
 * directory. If a
 * @returns The function `save` returns a boolean value - `true` if the saving operation is successful,
 * and `false` if there is an error during the process.
 */
export function save(
  deepKeyResult,
  dir,
  indexing = 2,
  fileName = autoGenerated
) {
  try {
    const resolvedDir = path.resolve(__dirname, dir);

    if (!fs.existsSync(resolvedDir)) {
      fs.mkdirSync(resolvedDir);
    }

    let file_name = fileName;

    if (typeof fileName === "function") {
      let size = fs.readdirSync(resolvedDir).length;
      file_name = fileName(size + 1);
    }

    const writableBuffer = JSON.stringify(deepKeyResult, null, indexing);
    fs.writeFileSync(resolvedDir + "/" + file_name + ".json", writableBuffer, {
      flag: "w+",
    });

    return true;
  } catch (error) {
    console.log(error);
    return false;
  }
}

/**
 * The `read` function reads and compares JSON files in a specified directory, handling errors and
 * returning false if necessary.
 * @param dir - The `dir` parameter in the `read` function represents the directory path where the
 * files are located that you want to read and compare. It is the directory path relative to the
 * current file's directory.
 * @param [index=0] - The `index` parameter in the `read` function is used to specify the index of the
 * file to be compared. If `index` is not provided, it defaults to 0 which means it will compare the
 * first file in the directory.
 * @param [index2=0] - The `index2` parameter in the `read` function is used to specify the index of
 * the second file to be compared. By default, if `index2` is not provided, it is set to 0 which
 * corresponds to the last file in the directory (files.length - 1).
 * @returns The `read` function is returning the result of calling the `keyDeffPrettifier` function
 * with the result of calling `keyDeff` function with the parsed JSON data from two files. The
 * `keyDeff` function compares the keys of two objects and returns the differences. The
 * `keyDeffPrettifier` function likely formats and displays these differences in a readable way.
 */
export function read(dir, index = 0, index2 = 0) {
  try {
    let files = fs.readdirSync(path.resolve(__dirname, dir));

    if (files.length === 1) throw new Error(dir + " Need at least two compare files!");

    let searchIndex = index === 0 ? files.length : index;
    let searchIndex2 = index2 === 0 ? files.length - 1 : index2;

    let file1 = files
      .filter((ls) => ls.split(".").at(0) === searchIndex.toString())
      .at(0);
    let file2 = files
      .filter((ls) => ls.split(".").at(0) === searchIndex2.toString())
      .at(0);

    let jsonFiles = [file1, file2];

    jsonFiles = jsonFiles.map((file) => {
      return JSON.parse(
        fs.readFileSync(path.resolve(__dirname, dir, file), "utf-8")
      );
    });

    keyDeffPrettifier(keyDeff(jsonFiles.at(0), jsonFiles.at(1)));
  } catch (error) {
    console.log(error);
    return false;
  }
}

/**
 * The `deep` function in JavaScript recursively analyzes the structure of an object and returns a map
 * of keys with their corresponding types.
 * @param obj - The `obj` parameter in the `deep` function is the object that you want to analyze
 * deeply to determine its structure and types of values. This function recursively traverses the
 * object and generates a map that represents the structure of the object with keys indicating the path
 * to each value and values indicating the type
 * @param [pKey] - The `pKey` parameter in the `deep` function stands for the parent key of the current
 * object being processed. It is used to keep track of the nested structure of the object during the
 * recursive traversal.
 * @param [memo] - The `memo` parameter in the `deep` function is a Map object that stores key-value
 * pairs where the key represents the path to a property in the object being processed, and the value
 * represents the type of that property. The function uses this `memo` map to keep track of the types
 * of
 * @returns The `deep` function returns an object that represents the deep structure of the input
 * object `obj`. Each key in the returned object corresponds to a path in the input object, and the
 * value at that key represents the type of the value at that path in the input object.
 */
export function deep(obj, pKey = "", memo = new Map()) {
  if (typeof obj !== "object") {
    let memoValue = memo.get(pKey) ?? "";
    let memoValueArr = memoValue.split(",").filter((ls) => ls.length > 0);
    let type = obj === "empty" ? "empty" : typeof obj;
    if (!memoValueArr.includes(type)) {
      memoValueArr.push(type);
    }
    let calculatedKey = memoValueArr.join(",");
    memo.set(pKey, calculatedKey);
  } else {
    let keys = Object.keys(obj);
    keys.forEach((k) => {
      let calculatedKeyRoot = pKey
        ? pKey + (isNaN(parseInt(k)) ? "." + k : "")
        : k;
      let isArray = typeof obj[k] === "object" && Array.isArray(obj[k]);
      let isObject = typeof obj[k] === "object" && !Array.isArray(obj[k]);

      if (isArray) {
        let calArrValue = obj[k].length ? obj[k] : (obj[k] = ["empty"]);
        calArrValue.map((ls) => {
          let isArrObj = typeof ls === "object" && !Array.isArray(ls);
          deep(ls, calculatedKeyRoot + (isArrObj ? `[]{}` : `[]`), memo);
        });
      } else if (isObject) {
        deep(obj[k], calculatedKeyRoot + "{}", memo);
      } else {
        memo.set(calculatedKeyRoot, typeof obj[k]);
      }
    });
  }

  return Object.fromEntries(memo.entries());
}
